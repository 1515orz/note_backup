# 并发问题


## 常见问题

### 丢失更新(lost updates)
当两个事务尝试更新相同的数据并且没有上锁时,较晚提交的事务会覆盖较早事务做的更改
_假如有两个事务都试图更新同一个客户,一个想增加积分,一个想更新州,则后提交的会覆盖先提交的,从而丢失先提交的更新_

### 脏读(dirty read)
脏读: 是当一个事务读取了尚未被提交的数据
_在A提交数据时,数据被B读取,但是A实际没有进行提交,而是让数据进行了回滚,B对数据的读取就被称作脏读_**事务B读取了未提交的数据,因此我们的数据是脏的**
#### 解决方法
设立隔离区: 在 A`COMMIT提交数据`之前不允许被读取
标准的SQL定义了4个事务隔离级别,
* READ COMMITTED==隔离级别== `这个事务只能读取已提交的数据`,从而避免脏读

### 不可复读(Non-repeating Reads)

当我们在事务中添加更多隔离时,我们可以保证事务只能读取已提交的数据,_但是在事务过程中,你读了某个数据两次,并得到了不同的结果怎么办?_
* 无论何时,我们一般应该根据最新信息做决定,为了保证复读数据相同,我们要设置`事务隔离`,确保数据更改对事务不可见
#### 可重复读 (Repeatable Reads) ==隔离级别==
* 就算有其他事务更改了数据,我们都护看到首次读取就创建的快照,让重复读的结果不发生改变


### 幻读 (Phantom Reads)
在`执行查询`的时候,出现就像幽灵一样突然出现的数据,`因为他们是在执行查询后才添加,更新或删除的`
#### 避免幻读
* 我们总是可以在更新完数据后再执行查询,避免幻读
* 确保没有会影响我们查询结果的事务正在运行


## 隔离级别总结
* `序列化`(Serializable)==隔离级别====: 保证当前还有别的事务在更新数据时,我们的事务能知晓变动,_如果有其他事务修改了有可能影响我们数据查询结果的事务,我们的事务必须等待他们完成_这样事务就可以按序列化执行
* 这是我们可以应用于一个事务的`最高隔离级别`,这为我们的操作提供了最大的确定性
* 我们拥有的用户和并发事务越多,我们就要等越久,我们就要等越久,我们的系统也会变慢
* 所以隔离级别会损害性能和可扩展性
* 我们应该只有在真的有必要防止幻读的情况下才保留此项(phantom reads)




