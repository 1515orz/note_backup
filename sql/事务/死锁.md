# 死锁(dead lock)

`死锁` 就是当不同事务均因抓住了别的事务需要的`锁`而无法完成的情况
_所以两个事务都一直在等待对方,并永远没法释放锁_
* 当我们想更新记录,MySQL会锁定该条记录,这样其他用户必须等待,但是两方用户操作的事务同时锁住了对方更新的数据时,死锁就形成了
* 一般来说,死锁不是什么大问题,除非他们经常发生
* 如果你是开发者,可以编写_如果事务因为死锁被退回,可以重新恢复,或者告诉用户,“这次操作失败了,请再次尝试”_
* 你永远无法真正消除`死锁`,只能减小可能性,并减少它的危害

```MySQL
sessionA:
  START TRANSACTION;
  UPDATE customers SET state = 'VA' WHERE customer_id = 1;
  UPDATE orders SET status = 1 WHERE order_id = 1;
  # A在第一行执行的时候锁定了第一条数据,并且尝试更新第二条数据;
  # B在第一行执行的时候锁定了第二条数据,并且尝试更新第一条数据
  # "死锁"形成,互相锁住了对方想要操作的数据,只能进行不可能的等待
  COMMIT;

sessionB:
  START TRANSACTION;
  UPDATE orders SET status = 1 WHERE order_id = 1;
  UPDATE customers SET state = 'VA' WHERE customer_id = 1;
  # 交换了更新的两行内容
  COMMIT;

```

### 死锁处理

1. 如果你有两个事务经常出现`死锁`,这些事务可能是储存过程的一部分,检查一下事务里语句的顺序,如果这些事务以**相反的顺序更新记录**就很有可能出现`死锁`,为了减少`死锁`,我们可以在==更新多条记录的时候可以遵照相同的顺序==
2. 你还可以做的是,==尽量简化事务,缩小事务运行时长==,这样他们就不太可能和其他事务冲突
3. 如果你的表要基于非常大的表运行,这些事务可能要运行很长事件,就会有冲突的风险,在这种情况==可以把那些事务安排在非高峰时段运行==从而避免大量活跃用户
